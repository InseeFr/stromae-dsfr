/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * queen-api
 * API for Queen/Stromae
 * OpenAPI spec version: 5.0.0-rc
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  CleanDataParams,
  GetInterrogationsByStateParams,
  Interrogation,
  InterrogationCreation,
  InterrogationDataStateDataUpdate,
  InterrogationMetadata,
  InterrogationStateDto,
  InterrogationSummary,
  InterrogationUpdate,
  InterrogationsOkNok,
  StateData,
  StateDataUpdate,
} from '../models/api'
import type { SchemaData } from '../models/api/schema.data'
import type { SchemaPersonalization } from '../models/api/schema.personalization'
import { stromaeInstance } from './axiosInstance'
import { depositProofInstance } from './axiosInstance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Authorized roles: ADMIN / WEBCLIENT / REVIEWER / REVIEWER_ALTERNATIVE / INTERVIEWER / SURVEY_UNIT /
 * @summary Get interrogation
 */
export const getInterrogationById = (
  id: string,
  options?: SecondParameter<typeof stromaeInstance>,
  signal?: AbortSignal,
) => {
  return stromaeInstance<Interrogation>(
    { url: `/api/interrogations/${id}`, method: 'GET', signal },
    options,
  )
}

export const getGetInterrogationByIdQueryKey = (id: string) => {
  return [`/api/interrogations/${id}`] as const
}

export const getGetInterrogationByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getInterrogationById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInterrogationByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInterrogationById>>
  > = ({ signal }) => getInterrogationById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getInterrogationById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GetInterrogationByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInterrogationById>>
>
export type GetInterrogationByIdQueryError = unknown

export function useGetInterrogationById<
  TData = Awaited<ReturnType<typeof getInterrogationById>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterrogationById>>,
          TError,
          Awaited<ReturnType<typeof getInterrogationById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInterrogationById<
  TData = Awaited<ReturnType<typeof getInterrogationById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterrogationById>>,
          TError,
          Awaited<ReturnType<typeof getInterrogationById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInterrogationById<
  TData = Awaited<ReturnType<typeof getInterrogationById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get interrogation
 */

export function useGetInterrogationById<
  TData = Awaited<ReturnType<typeof getInterrogationById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetInterrogationByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Authorized roles: ADMIN / WEBCLIENT / INTERVIEWER /
 * @summary Update interrogation
 */
export const updateInterrogationById = (
  id: string,
  interrogationUpdate: InterrogationUpdate,
  options?: SecondParameter<typeof stromaeInstance>,
) => {
  return stromaeInstance<void>(
    {
      url: `/api/interrogations/${id}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: interrogationUpdate,
    },
    options,
  )
}

export const getUpdateInterrogationByIdMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateInterrogationById>>,
    TError,
    { id: string; data: InterrogationUpdate },
    TContext
  >
  request?: SecondParameter<typeof stromaeInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateInterrogationById>>,
  TError,
  { id: string; data: InterrogationUpdate },
  TContext
> => {
  const mutationKey = ['updateInterrogationById']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateInterrogationById>>,
    { id: string; data: InterrogationUpdate }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateInterrogationById(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateInterrogationByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateInterrogationById>>
>
export type UpdateInterrogationByIdMutationBody = InterrogationUpdate
export type UpdateInterrogationByIdMutationError = unknown

/**
 * @summary Update interrogation
 */
export const useUpdateInterrogationById = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateInterrogationById>>,
      TError,
      { id: string; data: InterrogationUpdate },
      TContext
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateInterrogationById>>,
  TError,
  { id: string; data: InterrogationUpdate },
  TContext
> => {
  const mutationOptions = getUpdateInterrogationByIdMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Authorized roles: ADMIN / WEBCLIENT /
 * @summary Delete an interrogation
 */
export const deleteInterrogation = (
  id: string,
  options?: SecondParameter<typeof stromaeInstance>,
) => {
  return stromaeInstance<void>(
    { url: `/api/interrogations/${id}`, method: 'DELETE' },
    options,
  )
}

export const getDeleteInterrogationMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteInterrogation>>,
    TError,
    { id: string },
    TContext
  >
  request?: SecondParameter<typeof stromaeInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteInterrogation>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteInterrogation']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteInterrogation>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteInterrogation(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteInterrogationMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteInterrogation>>
>

export type DeleteInterrogationMutationError = unknown

/**
 * @summary Delete an interrogation
 */
export const useDeleteInterrogation = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteInterrogation>>,
      TError,
      { id: string },
      TContext
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteInterrogation>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteInterrogationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Authorized roles: ADMIN / WEBCLIENT / INTERVIEWER / SURVEY_UNIT /
 * @summary Update interrogation updated data/state-data
 */
export const updateInterrogationDataStateDataById = (
  id: string,
  interrogationDataStateDataUpdate: InterrogationDataStateDataUpdate,
  options?: SecondParameter<typeof stromaeInstance>,
) => {
  return stromaeInstance<void>(
    {
      url: `/api/interrogations/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: interrogationDataStateDataUpdate,
    },
    options,
  )
}

export const getUpdateInterrogationDataStateDataByIdMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateInterrogationDataStateDataById>>,
    TError,
    { id: string; data: InterrogationDataStateDataUpdate },
    TContext
  >
  request?: SecondParameter<typeof stromaeInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateInterrogationDataStateDataById>>,
  TError,
  { id: string; data: InterrogationDataStateDataUpdate },
  TContext
> => {
  const mutationKey = ['updateInterrogationDataStateDataById']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateInterrogationDataStateDataById>>,
    { id: string; data: InterrogationDataStateDataUpdate }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateInterrogationDataStateDataById(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateInterrogationDataStateDataByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateInterrogationDataStateDataById>>
>
export type UpdateInterrogationDataStateDataByIdMutationBody =
  InterrogationDataStateDataUpdate
export type UpdateInterrogationDataStateDataByIdMutationError = unknown

/**
 * @summary Update interrogation updated data/state-data
 */
export const useUpdateInterrogationDataStateDataById = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateInterrogationDataStateDataById>>,
      TError,
      { id: string; data: InterrogationDataStateDataUpdate },
      TContext
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateInterrogationDataStateDataById>>,
  TError,
  { id: string; data: InterrogationDataStateDataUpdate },
  TContext
> => {
  const mutationOptions =
    getUpdateInterrogationDataStateDataByIdMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Authorized roles: ADMIN / WEBCLIENT / REVIEWER / REVIEWER_ALTERNATIVE / INTERVIEWER / SURVEY_UNIT /
 * @summary Get state-data for an interrogation
 */
export const getStateDataByInterrogation = (
  id: string,
  options?: SecondParameter<typeof stromaeInstance>,
  signal?: AbortSignal,
) => {
  return stromaeInstance<StateData>(
    { url: `/api/interrogations/${id}/state-data`, method: 'GET', signal },
    options,
  )
}

export const getGetStateDataByInterrogationQueryKey = (id: string) => {
  return [`/api/interrogations/${id}/state-data`] as const
}

export const getGetStateDataByInterrogationQueryOptions = <
  TData = Awaited<ReturnType<typeof getStateDataByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStateDataByInterrogation>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetStateDataByInterrogationQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getStateDataByInterrogation>>
  > = ({ signal }) => getStateDataByInterrogation(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getStateDataByInterrogation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GetStateDataByInterrogationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStateDataByInterrogation>>
>
export type GetStateDataByInterrogationQueryError = unknown

export function useGetStateDataByInterrogation<
  TData = Awaited<ReturnType<typeof getStateDataByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStateDataByInterrogation>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStateDataByInterrogation>>,
          TError,
          Awaited<ReturnType<typeof getStateDataByInterrogation>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetStateDataByInterrogation<
  TData = Awaited<ReturnType<typeof getStateDataByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStateDataByInterrogation>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStateDataByInterrogation>>,
          TError,
          Awaited<ReturnType<typeof getStateDataByInterrogation>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetStateDataByInterrogation<
  TData = Awaited<ReturnType<typeof getStateDataByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStateDataByInterrogation>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get state-data for an interrogation
 */

export function useGetStateDataByInterrogation<
  TData = Awaited<ReturnType<typeof getStateDataByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStateDataByInterrogation>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStateDataByInterrogationQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Authorized roles: ADMIN / WEBCLIENT / INTERVIEWER / SURVEY_UNIT /
 * @summary Update state-data for an interrogation
 */
export const setStateData = (
  id: string,
  stateDataUpdate: StateDataUpdate,
  options?: SecondParameter<typeof stromaeInstance>,
) => {
  return stromaeInstance<void>(
    {
      url: `/api/interrogations/${id}/state-data`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: stateDataUpdate,
    },
    options,
  )
}

export const getSetStateDataMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setStateData>>,
    TError,
    { id: string; data: StateDataUpdate },
    TContext
  >
  request?: SecondParameter<typeof stromaeInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof setStateData>>,
  TError,
  { id: string; data: StateDataUpdate },
  TContext
> => {
  const mutationKey = ['setStateData']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setStateData>>,
    { id: string; data: StateDataUpdate }
  > = (props) => {
    const { id, data } = props ?? {}

    return setStateData(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SetStateDataMutationResult = NonNullable<
  Awaited<ReturnType<typeof setStateData>>
>
export type SetStateDataMutationBody = StateDataUpdate
export type SetStateDataMutationError = unknown

/**
 * @summary Update state-data for an interrogation
 */
export const useSetStateData = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof setStateData>>,
      TError,
      { id: string; data: StateDataUpdate },
      TContext
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof setStateData>>,
  TError,
  { id: string; data: StateDataUpdate },
  TContext
> => {
  const mutationOptions = getSetStateDataMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Authorized roles: ADMIN / WEBCLIENT / REVIEWER / REVIEWER_ALTERNATIVE / INTERVIEWER / SURVEY_UNIT /
 * @summary Get personalization for an interrogation
 */
export const getPersonalizationByInterrogation = (
  id: string,
  options?: SecondParameter<typeof stromaeInstance>,
  signal?: AbortSignal,
) => {
  return stromaeInstance<SchemaPersonalization>(
    { url: `/api/interrogations/${id}/personalization`, method: 'GET', signal },
    options,
  )
}

export const getGetPersonalizationByInterrogationQueryKey = (id: string) => {
  return [`/api/interrogations/${id}/personalization`] as const
}

export const getGetPersonalizationByInterrogationQueryOptions = <
  TData = Awaited<ReturnType<typeof getPersonalizationByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonalizationByInterrogation>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetPersonalizationByInterrogationQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPersonalizationByInterrogation>>
  > = ({ signal }) =>
    getPersonalizationByInterrogation(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPersonalizationByInterrogation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPersonalizationByInterrogationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPersonalizationByInterrogation>>
>
export type GetPersonalizationByInterrogationQueryError = unknown

export function useGetPersonalizationByInterrogation<
  TData = Awaited<ReturnType<typeof getPersonalizationByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonalizationByInterrogation>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPersonalizationByInterrogation>>,
          TError,
          Awaited<ReturnType<typeof getPersonalizationByInterrogation>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPersonalizationByInterrogation<
  TData = Awaited<ReturnType<typeof getPersonalizationByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonalizationByInterrogation>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPersonalizationByInterrogation>>,
          TError,
          Awaited<ReturnType<typeof getPersonalizationByInterrogation>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPersonalizationByInterrogation<
  TData = Awaited<ReturnType<typeof getPersonalizationByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonalizationByInterrogation>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get personalization for an interrogation
 */

export function useGetPersonalizationByInterrogation<
  TData = Awaited<ReturnType<typeof getPersonalizationByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonalizationByInterrogation>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPersonalizationByInterrogationQueryOptions(
    id,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Authorized roles: ADMIN / WEBCLIENT /
 * @summary Update personalization for an interrogation
 */
export const setPersonalization = (
  id: string,
  schemaPersonalization: SchemaPersonalization,
  options?: SecondParameter<typeof stromaeInstance>,
) => {
  return stromaeInstance<void>(
    {
      url: `/api/interrogations/${id}/personalization`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: schemaPersonalization,
    },
    options,
  )
}

export const getSetPersonalizationMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setPersonalization>>,
    TError,
    { id: string; data: SchemaPersonalization },
    TContext
  >
  request?: SecondParameter<typeof stromaeInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof setPersonalization>>,
  TError,
  { id: string; data: SchemaPersonalization },
  TContext
> => {
  const mutationKey = ['setPersonalization']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setPersonalization>>,
    { id: string; data: SchemaPersonalization }
  > = (props) => {
    const { id, data } = props ?? {}

    return setPersonalization(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SetPersonalizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof setPersonalization>>
>
export type SetPersonalizationMutationBody = SchemaPersonalization
export type SetPersonalizationMutationError = unknown

/**
 * @summary Update personalization for an interrogation
 */
export const useSetPersonalization = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof setPersonalization>>,
      TError,
      { id: string; data: SchemaPersonalization },
      TContext
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof setPersonalization>>,
  TError,
  { id: string; data: SchemaPersonalization },
  TContext
> => {
  const mutationOptions = getSetPersonalizationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Authorized roles: ADMIN / WEBCLIENT / REVIEWER / REVIEWER_ALTERNATIVE / INTERVIEWER / SURVEY_UNIT /
 * @summary Get data for an interrogation
 */
export const getDataByInterrogation = (
  id: string,
  options?: SecondParameter<typeof stromaeInstance>,
  signal?: AbortSignal,
) => {
  return stromaeInstance<SchemaData>(
    { url: `/api/interrogations/${id}/data`, method: 'GET', signal },
    options,
  )
}

export const getGetDataByInterrogationQueryKey = (id: string) => {
  return [`/api/interrogations/${id}/data`] as const
}

export const getGetDataByInterrogationQueryOptions = <
  TData = Awaited<ReturnType<typeof getDataByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDataByInterrogation>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetDataByInterrogationQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDataByInterrogation>>
  > = ({ signal }) => getDataByInterrogation(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDataByInterrogation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDataByInterrogationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDataByInterrogation>>
>
export type GetDataByInterrogationQueryError = unknown

export function useGetDataByInterrogation<
  TData = Awaited<ReturnType<typeof getDataByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDataByInterrogation>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataByInterrogation>>,
          TError,
          Awaited<ReturnType<typeof getDataByInterrogation>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDataByInterrogation<
  TData = Awaited<ReturnType<typeof getDataByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDataByInterrogation>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataByInterrogation>>,
          TError,
          Awaited<ReturnType<typeof getDataByInterrogation>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDataByInterrogation<
  TData = Awaited<ReturnType<typeof getDataByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDataByInterrogation>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get data for an interrogation
 */

export function useGetDataByInterrogation<
  TData = Awaited<ReturnType<typeof getDataByInterrogation>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDataByInterrogation>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetDataByInterrogationQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Authorized roles: ADMIN / WEBCLIENT / INTERVIEWER / SURVEY_UNIT /
 * @summary Update data for an interrogation
 */
export const updateData = (
  id: string,
  schemaData: SchemaData,
  options?: SecondParameter<typeof stromaeInstance>,
) => {
  return stromaeInstance<void>(
    {
      url: `/api/interrogations/${id}/data`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: schemaData,
    },
    options,
  )
}

export const getUpdateDataMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateData>>,
    TError,
    { id: string; data: SchemaData },
    TContext
  >
  request?: SecondParameter<typeof stromaeInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateData>>,
  TError,
  { id: string; data: SchemaData },
  TContext
> => {
  const mutationKey = ['updateData']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateData>>,
    { id: string; data: SchemaData }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateData(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateDataMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateData>>
>
export type UpdateDataMutationBody = SchemaData
export type UpdateDataMutationError = unknown

/**
 * @summary Update data for an interrogation
 */
export const useUpdateData = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateData>>,
      TError,
      { id: string; data: SchemaData },
      TContext
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateData>>,
  TError,
  { id: string; data: SchemaData },
  TContext
> => {
  const mutationOptions = getUpdateDataMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Authorized roles: ADMIN / WEBCLIENT / REVIEWER / REVIEWER_ALTERNATIVE / INTERVIEWER /
 * @summary Get state-data for all interrogations defined in request body
 */
export const getStateDataByInterrogations = (
  getStateDataByInterrogationsBody: string[],
  options?: SecondParameter<typeof stromaeInstance>,
  signal?: AbortSignal,
) => {
  return stromaeInstance<InterrogationsOkNok>(
    {
      url: `/api/interrogations/state-data`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: getStateDataByInterrogationsBody,
      signal,
    },
    options,
  )
}

export const getGetStateDataByInterrogationsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getStateDataByInterrogations>>,
    TError,
    { data: string[] },
    TContext
  >
  request?: SecondParameter<typeof stromaeInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof getStateDataByInterrogations>>,
  TError,
  { data: string[] },
  TContext
> => {
  const mutationKey = ['getStateDataByInterrogations']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getStateDataByInterrogations>>,
    { data: string[] }
  > = (props) => {
    const { data } = props ?? {}

    return getStateDataByInterrogations(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type GetStateDataByInterrogationsMutationResult = NonNullable<
  Awaited<ReturnType<typeof getStateDataByInterrogations>>
>
export type GetStateDataByInterrogationsMutationBody = string[]
export type GetStateDataByInterrogationsMutationError = unknown

/**
 * @summary Get state-data for all interrogations defined in request body
 */
export const useGetStateDataByInterrogations = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof getStateDataByInterrogations>>,
      TError,
      { data: string[] },
      TContext
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof getStateDataByInterrogations>>,
  TError,
  { data: string[] },
  TContext
> => {
  const mutationOptions =
    getGetStateDataByInterrogationsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Authorized roles: ADMIN / WEBCLIENT /
 * @summary Create/Update an interrogation
 */
export const createUpdateInterrogation = (
  id: string,
  interrogationCreation: InterrogationCreation,
  options?: SecondParameter<typeof stromaeInstance>,
  signal?: AbortSignal,
) => {
  return stromaeInstance<void>(
    {
      url: `/api/campaign/${id}/interrogation`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: interrogationCreation,
      signal,
    },
    options,
  )
}

export const getCreateUpdateInterrogationMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUpdateInterrogation>>,
    TError,
    { id: string; data: InterrogationCreation },
    TContext
  >
  request?: SecondParameter<typeof stromaeInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUpdateInterrogation>>,
  TError,
  { id: string; data: InterrogationCreation },
  TContext
> => {
  const mutationKey = ['createUpdateInterrogation']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUpdateInterrogation>>,
    { id: string; data: InterrogationCreation }
  > = (props) => {
    const { id, data } = props ?? {}

    return createUpdateInterrogation(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateUpdateInterrogationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUpdateInterrogation>>
>
export type CreateUpdateInterrogationMutationBody = InterrogationCreation
export type CreateUpdateInterrogationMutationError = unknown

/**
 * @summary Create/Update an interrogation
 */
export const useCreateUpdateInterrogation = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUpdateInterrogation>>,
      TError,
      { id: string; data: InterrogationCreation },
      TContext
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createUpdateInterrogation>>,
  TError,
  { id: string; data: InterrogationCreation },
  TContext
> => {
  const mutationOptions = getCreateUpdateInterrogationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Authorized roles: ADMIN / WEBCLIENT /
 * @summary Get all interrogations ids
 */
export const getInterrogationIds = (
  options?: SecondParameter<typeof stromaeInstance>,
  signal?: AbortSignal,
) => {
  return stromaeInstance<string[]>(
    { url: `/api/interrogations`, method: 'GET', signal },
    options,
  )
}

export const getGetInterrogationIdsQueryKey = () => {
  return [`/api/interrogations`] as const
}

export const getGetInterrogationIdsQueryOptions = <
  TData = Awaited<ReturnType<typeof getInterrogationIds>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getInterrogationIds>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof stromaeInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInterrogationIdsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInterrogationIds>>
  > = ({ signal }) => getInterrogationIds(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInterrogationIds>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GetInterrogationIdsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInterrogationIds>>
>
export type GetInterrogationIdsQueryError = unknown

export function useGetInterrogationIds<
  TData = Awaited<ReturnType<typeof getInterrogationIds>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationIds>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterrogationIds>>,
          TError,
          Awaited<ReturnType<typeof getInterrogationIds>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInterrogationIds<
  TData = Awaited<ReturnType<typeof getInterrogationIds>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationIds>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterrogationIds>>,
          TError,
          Awaited<ReturnType<typeof getInterrogationIds>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInterrogationIds<
  TData = Awaited<ReturnType<typeof getInterrogationIds>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationIds>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get all interrogations ids
 */

export function useGetInterrogationIds<
  TData = Awaited<ReturnType<typeof getInterrogationIds>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationIds>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetInterrogationIdsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Authorized roles: ADMIN / WEBCLIENT / REVIEWER / REVIEWER_ALTERNATIVE / INTERVIEWER / SURVEY_UNIT /
 * @summary Get interrogation metadata
 */
export const getInterrogationMetadataById = (
  id: string,
  options?: SecondParameter<typeof stromaeInstance>,
  signal?: AbortSignal,
) => {
  return stromaeInstance<InterrogationMetadata>(
    { url: `/api/interrogations/${id}/metadata`, method: 'GET', signal },
    options,
  )
}

export const getGetInterrogationMetadataByIdQueryKey = (id: string) => {
  return [`/api/interrogations/${id}/metadata`] as const
}

export const getGetInterrogationMetadataByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getInterrogationMetadataById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationMetadataById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetInterrogationMetadataByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInterrogationMetadataById>>
  > = ({ signal }) => getInterrogationMetadataById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getInterrogationMetadataById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GetInterrogationMetadataByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInterrogationMetadataById>>
>
export type GetInterrogationMetadataByIdQueryError = unknown

export function useGetInterrogationMetadataById<
  TData = Awaited<ReturnType<typeof getInterrogationMetadataById>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationMetadataById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterrogationMetadataById>>,
          TError,
          Awaited<ReturnType<typeof getInterrogationMetadataById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInterrogationMetadataById<
  TData = Awaited<ReturnType<typeof getInterrogationMetadataById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationMetadataById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterrogationMetadataById>>,
          TError,
          Awaited<ReturnType<typeof getInterrogationMetadataById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInterrogationMetadataById<
  TData = Awaited<ReturnType<typeof getInterrogationMetadataById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationMetadataById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get interrogation metadata
 */

export function useGetInterrogationMetadataById<
  TData = Awaited<ReturnType<typeof getInterrogationMetadataById>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationMetadataById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetInterrogationMetadataByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Authorized roles: ADMIN / WEBCLIENT / REVIEWER / REVIEWER_ALTERNATIVE / INTERVIEWER / SURVEY_UNIT /
 * @summary Get deposit proof for an interrogation
 */
export const generateDepositProof = (
  id: string,
  options?: SecondParameter<typeof depositProofInstance>,
  signal?: AbortSignal,
) => {
  return depositProofInstance<Blob>(
    {
      url: `/api/interrogations/${id}/deposit-proof`,
      method: 'GET',
      responseType: 'blob',
      signal,
    },
    options,
  )
}

export const getGenerateDepositProofQueryKey = (id: string) => {
  return [`/api/interrogations/${id}/deposit-proof`] as const
}

export const getGenerateDepositProofQueryOptions = <
  TData = Awaited<ReturnType<typeof generateDepositProof>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof generateDepositProof>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof depositProofInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGenerateDepositProofQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof generateDepositProof>>
  > = ({ signal }) => generateDepositProof(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof generateDepositProof>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GenerateDepositProofQueryResult = NonNullable<
  Awaited<ReturnType<typeof generateDepositProof>>
>
export type GenerateDepositProofQueryError = unknown

export function useGenerateDepositProof<
  TData = Awaited<ReturnType<typeof generateDepositProof>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof generateDepositProof>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof generateDepositProof>>,
          TError,
          Awaited<ReturnType<typeof generateDepositProof>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof depositProofInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGenerateDepositProof<
  TData = Awaited<ReturnType<typeof generateDepositProof>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof generateDepositProof>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof generateDepositProof>>,
          TError,
          Awaited<ReturnType<typeof generateDepositProof>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof depositProofInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGenerateDepositProof<
  TData = Awaited<ReturnType<typeof generateDepositProof>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof generateDepositProof>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof depositProofInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get deposit proof for an interrogation
 */

export function useGenerateDepositProof<
  TData = Awaited<ReturnType<typeof generateDepositProof>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof generateDepositProof>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof depositProofInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGenerateDepositProofQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Authorized roles: ADMIN / WEBCLIENT / INTERVIEWER /
 * @summary Get list of interrogations linked to the current interviewer
 */
export const getInterviewerInterrogations = (
  options?: SecondParameter<typeof stromaeInstance>,
  signal?: AbortSignal,
) => {
  return stromaeInstance<Interrogation[]>(
    { url: `/api/interrogations/interviewer`, method: 'GET', signal },
    options,
  )
}

export const getGetInterviewerInterrogationsQueryKey = () => {
  return [`/api/interrogations/interviewer`] as const
}

export const getGetInterviewerInterrogationsQueryOptions = <
  TData = Awaited<ReturnType<typeof getInterviewerInterrogations>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getInterviewerInterrogations>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof stromaeInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetInterviewerInterrogationsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInterviewerInterrogations>>
  > = ({ signal }) => getInterviewerInterrogations(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInterviewerInterrogations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GetInterviewerInterrogationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInterviewerInterrogations>>
>
export type GetInterviewerInterrogationsQueryError = unknown

export function useGetInterviewerInterrogations<
  TData = Awaited<ReturnType<typeof getInterviewerInterrogations>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterviewerInterrogations>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterviewerInterrogations>>,
          TError,
          Awaited<ReturnType<typeof getInterviewerInterrogations>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInterviewerInterrogations<
  TData = Awaited<ReturnType<typeof getInterviewerInterrogations>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterviewerInterrogations>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterviewerInterrogations>>,
          TError,
          Awaited<ReturnType<typeof getInterviewerInterrogations>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInterviewerInterrogations<
  TData = Awaited<ReturnType<typeof getInterviewerInterrogations>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterviewerInterrogations>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of interrogations linked to the current interviewer
 */

export function useGetInterviewerInterrogations<
  TData = Awaited<ReturnType<typeof getInterviewerInterrogations>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterviewerInterrogations>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetInterviewerInterrogationsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Authorized roles: ADMIN / WEBCLIENT / REVIEWER / REVIEWER_ALTERNATIVE / INTERVIEWER /
 * @summary Get list of interrogations for a campaign
 */
export const getListInterrogationByCampaign = (
  id: string,
  options?: SecondParameter<typeof stromaeInstance>,
  signal?: AbortSignal,
) => {
  return stromaeInstance<InterrogationSummary[]>(
    { url: `/api/campaign/${id}/interrogations`, method: 'GET', signal },
    options,
  )
}

export const getGetListInterrogationByCampaignQueryKey = (id: string) => {
  return [`/api/campaign/${id}/interrogations`] as const
}

export const getGetListInterrogationByCampaignQueryOptions = <
  TData = Awaited<ReturnType<typeof getListInterrogationByCampaign>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getListInterrogationByCampaign>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetListInterrogationByCampaignQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getListInterrogationByCampaign>>
  > = ({ signal }) => getListInterrogationByCampaign(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getListInterrogationByCampaign>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GetListInterrogationByCampaignQueryResult = NonNullable<
  Awaited<ReturnType<typeof getListInterrogationByCampaign>>
>
export type GetListInterrogationByCampaignQueryError = unknown

export function useGetListInterrogationByCampaign<
  TData = Awaited<ReturnType<typeof getListInterrogationByCampaign>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getListInterrogationByCampaign>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getListInterrogationByCampaign>>,
          TError,
          Awaited<ReturnType<typeof getListInterrogationByCampaign>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetListInterrogationByCampaign<
  TData = Awaited<ReturnType<typeof getListInterrogationByCampaign>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getListInterrogationByCampaign>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getListInterrogationByCampaign>>,
          TError,
          Awaited<ReturnType<typeof getListInterrogationByCampaign>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetListInterrogationByCampaign<
  TData = Awaited<ReturnType<typeof getListInterrogationByCampaign>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getListInterrogationByCampaign>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get list of interrogations for a campaign
 */

export function useGetListInterrogationByCampaign<
  TData = Awaited<ReturnType<typeof getListInterrogationByCampaign>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getListInterrogationByCampaign>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetListInterrogationByCampaignQueryOptions(
    id,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Authorized roles: ADMIN / WEBCLIENT /
 * @summary Retrieve interrogations by state
 */
export const getInterrogationsByState = (
  id: string,
  params: GetInterrogationsByStateParams,
  options?: SecondParameter<typeof stromaeInstance>,
  signal?: AbortSignal,
) => {
  return stromaeInstance<InterrogationStateDto[]>(
    {
      url: `/api/admin/campaign/${id}/interrogations`,
      method: 'GET',
      params,
      signal,
    },
    options,
  )
}

export const getGetInterrogationsByStateQueryKey = (
  id: string,
  params: GetInterrogationsByStateParams,
) => {
  return [
    `/api/admin/campaign/${id}/interrogations`,
    ...(params ? [params] : []),
  ] as const
}

export const getGetInterrogationsByStateQueryOptions = <
  TData = Awaited<ReturnType<typeof getInterrogationsByState>>,
  TError = unknown,
>(
  id: string,
  params: GetInterrogationsByStateParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationsByState>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetInterrogationsByStateQueryKey(id, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInterrogationsByState>>
  > = ({ signal }) =>
    getInterrogationsByState(id, params, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getInterrogationsByState>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type GetInterrogationsByStateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInterrogationsByState>>
>
export type GetInterrogationsByStateQueryError = unknown

export function useGetInterrogationsByState<
  TData = Awaited<ReturnType<typeof getInterrogationsByState>>,
  TError = unknown,
>(
  id: string,
  params: GetInterrogationsByStateParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationsByState>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterrogationsByState>>,
          TError,
          Awaited<ReturnType<typeof getInterrogationsByState>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInterrogationsByState<
  TData = Awaited<ReturnType<typeof getInterrogationsByState>>,
  TError = unknown,
>(
  id: string,
  params: GetInterrogationsByStateParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationsByState>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInterrogationsByState>>,
          TError,
          Awaited<ReturnType<typeof getInterrogationsByState>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInterrogationsByState<
  TData = Awaited<ReturnType<typeof getInterrogationsByState>>,
  TError = unknown,
>(
  id: string,
  params: GetInterrogationsByStateParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationsByState>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve interrogations by state
 */

export function useGetInterrogationsByState<
  TData = Awaited<ReturnType<typeof getInterrogationsByState>>,
  TError = unknown,
>(
  id: string,
  params: GetInterrogationsByStateParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInterrogationsByState>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetInterrogationsByStateQueryOptions(
    id,
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Authorized roles:
 * @summary Clean all data from interrogations of a campaign with extracted state
 */
export const cleanData = (
  id: string,
  params: CleanDataParams,
  options?: SecondParameter<typeof stromaeInstance>,
) => {
  return stromaeInstance<void>(
    {
      url: `/api/admin/campaign/${id}/interrogations/data/extracted`,
      method: 'DELETE',
      params,
    },
    options,
  )
}

export const getCleanDataMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cleanData>>,
    TError,
    { id: string; params: CleanDataParams },
    TContext
  >
  request?: SecondParameter<typeof stromaeInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof cleanData>>,
  TError,
  { id: string; params: CleanDataParams },
  TContext
> => {
  const mutationKey = ['cleanData']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cleanData>>,
    { id: string; params: CleanDataParams }
  > = (props) => {
    const { id, params } = props ?? {}

    return cleanData(id, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CleanDataMutationResult = NonNullable<
  Awaited<ReturnType<typeof cleanData>>
>

export type CleanDataMutationError = unknown

/**
 * @summary Clean all data from interrogations of a campaign with extracted state
 */
export const useCleanData = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cleanData>>,
      TError,
      { id: string; params: CleanDataParams },
      TContext
    >
    request?: SecondParameter<typeof stromaeInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof cleanData>>,
  TError,
  { id: string; params: CleanDataParams },
  TContext
> => {
  const mutationOptions = getCleanDataMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
